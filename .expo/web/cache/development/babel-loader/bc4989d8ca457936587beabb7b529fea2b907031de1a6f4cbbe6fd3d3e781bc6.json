{"ast":null,"code":"export default function formatWithMask(props) {\n  var text = props.text,\n    mask = props.mask,\n    _props$obfuscationCha = props.obfuscationCharacter,\n    obfuscationCharacter = _props$obfuscationCha === void 0 ? '*' : _props$obfuscationCha,\n    _props$maskAutoComple = props.maskAutoComplete,\n    maskAutoComplete = _props$maskAutoComple === void 0 ? false : _props$maskAutoComple;\n  if (!text) return {\n    masked: '',\n    unmasked: '',\n    obfuscated: ''\n  };\n  if (!mask) return {\n    masked: text || '',\n    unmasked: text || '',\n    obfuscated: text || ''\n  };\n  var maskArray = typeof mask === 'function' ? mask(text) : mask;\n  var masked = '';\n  var obfuscated = '';\n  var unmasked = '';\n  var maskCharIndex = 0;\n  var valueCharIndex = 0;\n  while (true) {\n    if (maskCharIndex === maskArray.length) {\n      break;\n    }\n    var maskChar = maskArray[maskCharIndex];\n    var valueChar = text[valueCharIndex];\n    if (valueCharIndex === text.length) {\n      if (typeof maskChar === 'string' && maskAutoComplete) {\n        masked += maskChar;\n        obfuscated += maskChar;\n        maskCharIndex += 1;\n        continue;\n      }\n      break;\n    }\n    if (maskChar === valueChar) {\n      masked += maskChar;\n      obfuscated += maskChar;\n      valueCharIndex += 1;\n      maskCharIndex += 1;\n      continue;\n    }\n    var unmaskedValueChar = text[valueCharIndex];\n    if (typeof maskChar === 'object') {\n      valueCharIndex += 1;\n      var shouldObsfucateChar = Array.isArray(maskChar);\n      var maskCharRegex = Array.isArray(maskChar) ? maskChar[0] : maskChar;\n      var matchRegex = RegExp(maskCharRegex).test(valueChar);\n      if (matchRegex) {\n        masked += valueChar;\n        obfuscated += shouldObsfucateChar ? obfuscationCharacter : valueChar;\n        unmasked += unmaskedValueChar;\n        maskCharIndex += 1;\n      }\n      continue;\n    } else {\n      masked += maskChar;\n      obfuscated += maskChar;\n      maskCharIndex += 1;\n      continue;\n    }\n  }\n  return {\n    masked: masked,\n    unmasked: unmasked,\n    obfuscated: obfuscated\n  };\n}","map":{"version":3,"names":["formatWithMask","props","text","mask","_props$obfuscationCha","obfuscationCharacter","_props$maskAutoComple","maskAutoComplete","masked","unmasked","obfuscated","maskArray","maskCharIndex","valueCharIndex","length","maskChar","valueChar","unmaskedValueChar","shouldObsfucateChar","Array","isArray","maskCharRegex","matchRegex","RegExp","test"],"sources":["D:\\Finacial-Management\\front-end\\node_modules\\react-native-mask-input\\lib\\module\\formatWithMask.ts"],"sourcesContent":["import type { FormatWithMaskProps, FormatWithMaskResult } from './formatWithMask.types';\n\nexport default function formatWithMask(\n  props: FormatWithMaskProps\n): FormatWithMaskResult {\n  const { text, mask, obfuscationCharacter = '*', maskAutoComplete = false } = props;\n\n  // make sure it'll not break with null or undefined inputs\n  if (!text) return { masked: '', unmasked: '', obfuscated: '' };\n  if (!mask)\n    return {\n      masked: text || '',\n      unmasked: text || '',\n      obfuscated: text || '',\n    };\n\n  let maskArray = typeof mask === 'function' ? mask(text) : mask;\n\n  let masked = '';\n  let obfuscated = '';\n  let unmasked = '';\n\n  let maskCharIndex = 0;\n  let valueCharIndex = 0;\n\n  while (true) {\n    // if mask is ended, break.\n    if (maskCharIndex === maskArray.length) {\n      break;\n    }\n\n    let maskChar = maskArray[maskCharIndex];\n    let valueChar = text[valueCharIndex];\n\n    // if value is ended, break.\n    if (valueCharIndex === text.length) {\n      if (typeof maskChar === 'string' && maskAutoComplete) {\n        masked += maskChar;\n        obfuscated += maskChar;\n\n        maskCharIndex += 1;\n        continue;\n      }\n      break;\n    }\n\n    // value equals mask: add to masked result and advance on both mask and value indexes\n    if (maskChar === valueChar) {\n      masked += maskChar;\n      obfuscated += maskChar;\n\n      valueCharIndex += 1;\n      maskCharIndex += 1;\n      continue;\n    }\n\n    let unmaskedValueChar = text[valueCharIndex];\n\n    // it's a regex maskChar: let's advance on value index and validate the value within the regex\n    if (typeof maskChar === 'object') {\n      // advance on value index\n      valueCharIndex += 1;\n\n      const shouldObsfucateChar = Array.isArray(maskChar);\n\n      const maskCharRegex = Array.isArray(maskChar) ? maskChar[0] : maskChar;\n\n      const matchRegex = RegExp(maskCharRegex).test(valueChar);\n\n      // value match regex: add to masked and unmasked result and advance on mask index too\n      if (matchRegex) {\n        masked += valueChar;\n        obfuscated += shouldObsfucateChar ? obfuscationCharacter : valueChar;\n        unmasked += unmaskedValueChar;\n\n        maskCharIndex += 1;\n      }\n\n      continue;\n    } else {\n      // it's a fixed maskChar: add to maskedResult and advance on mask index\n      masked += maskChar;\n      obfuscated += maskChar;\n\n      maskCharIndex += 1;\n      continue;\n    }\n  }\n\n  return { masked, unmasked, obfuscated };\n}\n"],"mappings":"AAEA,eAAe,SAASA,cAATA,CACbC,KADa,EAES;EACtB,IAAQC,IAAF,GAAuED,KAA7E,CAAQC,IAAF;IAAQC,IAAR,GAAuEF,KAA7E,CAAcE,IAAR;IAAAC,qBAAA,GAAuEH,KAA7E,CAAoBI,oBAAoB;IAApBA,oBAAoB,GAAAD,qBAAA,cAAG,GAArC,GAAAA,qBAAA;IAAAE,qBAAA,GAAuEL,KAA7E,CAAgDM,gBAAgB;IAAhBA,gBAAgB,GAAAD,qBAAA,cAAG,QAAAA,qBAAA;EAGnE,IAAI,CAACJ,IAAL,EAAW,OAAO;IAAEM,MAAM,EAAE,EAAV;IAAcC,QAAQ,EAAE,EAAxB;IAA4BC,UAAU,EAAE;EAAxC,CAAP;EACX,IAAI,CAACP,IAAL,EACE,OAAO;IACLK,MAAM,EAAEN,IAAI,IAAI,EADX;IAELO,QAAQ,EAAEP,IAAI,IAAI,EAFb;IAGLQ,UAAU,EAAER,IAAI,IAAI;EAHf,CAAP;EAMF,IAAIS,SAAS,GAAG,OAAOR,IAAP,KAAgB,UAAhB,GAA6BA,IAAI,CAACD,IAAD,CAAjC,GAA0CC,IAA1D;EAEA,IAAIK,MAAM,GAAG,EAAb;EACA,IAAIE,UAAU,GAAG,EAAjB;EACA,IAAID,QAAQ,GAAG,EAAf;EAEA,IAAIG,aAAa,GAAG,CAApB;EACA,IAAIC,cAAc,GAAG,CAArB;EAEA,OAAO,IAAP,EAAa;IAEX,IAAID,aAAa,KAAKD,SAAS,CAACG,MAAhC,EAAwC;MACtC;IACD;IAED,IAAIC,QAAQ,GAAGJ,SAAS,CAACC,aAAD,CAAxB;IACA,IAAII,SAAS,GAAGd,IAAI,CAACW,cAAD,CAApB;IAGA,IAAIA,cAAc,KAAKX,IAAI,CAACY,MAA5B,EAAoC;MAClC,IAAI,OAAOC,QAAP,KAAoB,QAApB,IAAgCR,gBAApC,EAAsD;QACpDC,MAAM,IAAIO,QAAV;QACAL,UAAU,IAAIK,QAAd;QAEAH,aAAa,IAAI,CAAjB;QACA;MACD;MACD;IACD;IAGD,IAAIG,QAAQ,KAAKC,SAAjB,EAA4B;MAC1BR,MAAM,IAAIO,QAAV;MACAL,UAAU,IAAIK,QAAd;MAEAF,cAAc,IAAI,CAAlB;MACAD,aAAa,IAAI,CAAjB;MACA;IACD;IAED,IAAIK,iBAAiB,GAAGf,IAAI,CAACW,cAAD,CAA5B;IAGA,IAAI,OAAOE,QAAP,KAAoB,QAAxB,EAAkC;MAEhCF,cAAc,IAAI,CAAlB;MAEA,IAAMK,mBAAmB,GAAGC,KAAK,CAACC,OAAN,CAAcL,QAAd,CAA5B;MAEA,IAAMM,aAAa,GAAGF,KAAK,CAACC,OAAN,CAAcL,QAAd,IAA0BA,QAAQ,CAAC,CAAD,CAAlC,GAAwCA,QAA9D;MAEA,IAAMO,UAAU,GAAGC,MAAM,CAACF,aAAD,CAAN,CAAsBG,IAAtB,CAA2BR,SAA3B,CAAnB;MAGA,IAAIM,UAAJ,EAAgB;QACdd,MAAM,IAAIQ,SAAV;QACAN,UAAU,IAAIQ,mBAAmB,GAAGb,oBAAH,GAA0BW,SAA3D;QACAP,QAAQ,IAAIQ,iBAAZ;QAEAL,aAAa,IAAI,CAAjB;MACD;MAED;IACD,CApBD,MAoBO;MAELJ,MAAM,IAAIO,QAAV;MACAL,UAAU,IAAIK,QAAd;MAEAH,aAAa,IAAI,CAAjB;MACA;IACD;EACF;EAED,OAAO;IAAEJ,MAAF,EAAEA,MAAF;IAAUC,QAAV,EAAUA,QAAV;IAAoBC,UAAA,EAAAA;EAApB,CAAP;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}